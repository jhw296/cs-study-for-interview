# 📖 학습 주제

- **주제**: 자료구조의 큰 그림
- **날짜**: 2024-10-23

---

## 📌 학습 내용 요약

### [자료구조와 알고리즘]

**자료구조**

- `자료구조` : 데이터를 다루기 위한 어떠한 구조

---

**알고리즘**

- `알고리즘` : 어떠한 목적을 이루기 위해 필요한 일련의 연산 절차

---

⇒ 어떤 자료구조가 사용되었는지에 따라 사용 가능한 알고리즘이 달라짐

### [시간 복잡도와 공간 복잡도]

**시간 복잡도**

- `시간 복잡도(time complexity)` : 입력 크기에 따른 프로그램 실행 시간(연산 횟수)의 척도
  - 실행 시간은 연산의 횟수에 비례

---

**공간 복잡도**

- `공간 복잡도(space complexity)` : 입력에 따른 메모리 사용량의 척도
- 메모리 사용량 多 → 공간 복잡도 大 / 메모리 사용량 少 → 공간 복잡도 小

⇒ 소스 코드나 프로그램이 얼마나 효율적인지 판단하는 척도 (대부분 시간 복잡도 사용)

---

**표기법**

- `빅 오 표기법(big O notation)` : 함수의 점근적 상한을 표기하는 방법

  → 시간 복잡도를 표현 시 `입력에 따른 실행 시간의 점근적 상한`을 의미

  → 공간 복잡도를 표현 시 `입력에 따라 필요한 메모리 자원의 양에 대한 점근적 상한`을 의미

  - **점근적 상한이란?**
    - n이 증가해 무한대로 커진다고 가정 → 실행 시간도도 n에 따라 증가 → 실행 시간 증가에도 한계 존재 (한계 = 점근적 상한)
  - **O(상한(n))**
    - n이 점점 증가해 무한대로 커져도 실행 시간이 대략 이 이상(상한)은 커지지 않는 것을 의미

      > O(n) : n이 증가하더라도 대략 n번 이상으로 연산하지는 않는 것을 의미
      >

      > O(n^2) : n이 증가하더라도 실행 시간 증가율이 n^2보다 작다는 것을 의미
  
  - **빅 오 표기법 유의점**
    - 점근적 상한 표현시 최고차항의 차수만 고려
    ![image (1)](https://github.com/user-attachments/assets/9a91ff09-3bf0-4444-a730-60e1cf8a6040)
    ![image (2)](https://github.com/user-attachments/assets/62eaac5d-ef69-4a38-b716-b5fe27ba3e47)

- `빅 세타 표기법(big θ notation)` : 평균적인 실행 시간

  > θ(n^2) : n이 증가하더라도 실행 시간 증가율은 n^2와 같다는 것을 의미
- `빅 오메가 표기법(big Ω notation)` : 입력에 대한 실행 시간의 점근적 하한
  > Ω(n^2) : n이 증가하더라도 실행 시간 증가율은 n^2보다 크다는 것을 의미

- **정렬 알고리즘의 시간 복잡도**
  - 삽입 정렬 : O(n^2)
  - 선택 정렬 : O(n^2)
  - 버블 정렬 : O(n^2)
  - 병합 정렬 : O(n log n)
  - 퀵 정렬 : O(n log n)
  - 힙 정렬 : O(n log n)


---

## 📈 추가 학습 필요

### **[정렬 알고리즘의 시간 복잡도]**

**삽입 정렬 (Insertion Sort)**

- **시간 복잡도:** O(n^2)
- **설명**: 삽입 정렬은 리스트의 두 번째 요소부터 현재 요소를 이전의 요소들과 비교하며 자신의 위치를 찾아 삽입하는 방식
- **최악의 경우**: 리스트가 역순으로 정렬되어 있는 경우 → 최대한의 이동 필요하므로 비교 횟수 多
- **최악의 시간 복잡도 분석**: 첫 번째 요소는 비교할 것 X, 두 번째 요소는 1번, 세 번째는 2번, ... n번째 요소는 n-1번 비교 → 이를 모두 더하면 1 + 2 + ... + (n-1) = n(n-1)/2이므로 시간 복잡도는 O(n^2)

**선택 정렬 (Selection Sort)**

- **시간 복잡도:** O(n^2)
- **설명**: 선택 정렬은 매번 배열에서 가장 작거나 큰 요소를 찾아 현재 위치에 놓는 방식
- **최악의 경우**: 모든 요소 다 비교 필요 → 배열이 어떤 상태에 있든 최악의 시간 복잡도
- **시간 복잡도 분석**: 처음 n개의 요소 중 가장 작은 요소를 찾기 위해 n번 비교 후 n-1번 비교 → 이를 반복하면 시간 복잡도는 O(n^2)

**버블 정렬 (Bubble Sort)**

- **시간 복잡도:** O(n^2)
- **설명**: 버블 정렬은 인접한 두 요소 비교 후 필요시 자리 교환하는 방식
- **최악의 경우**: 모든 요소가 역순으로 정렬되어 있는 경우 → 모든 요소 한 번씩 교환 필요
- **시간 복잡도 분석**: 각 순회에서 인접한 두 요소를 n-1번의 비교, 그 다음엔 n-2번, ... 마지막에는 1번 비교→  총 비교 횟수를 보면 시간 복잡도는 O(n^2)

**병합 정렬 (Merge Sort)**

- **시간 복잡도:** O(n log n)
- **설명**: 병합 정렬은 리스트를 절반씩 나누어 각 부분 정렬 후 다시 합치는 방식
- **최악의 경우:** 데이터 초기 상태와 관련없이 일정한 성능 —> 최악의 경우에도 성능 유지
- **시간 복잡도 분석**: 리스트를 절반으로 나누는 작업은 log n번 반복 → 각 단계 리스트의 모든 요소 병합하는 작업은 n번의 비교가 필요하므로 전체 시간 복잡도는 O(n log n)

**퀵 정렬 (Quick Sort)**

- **시간 복잡도:** 평균적으로 O(n log n), 최악의 경우 O(n^2)
- **설명**: 퀵 정렬은 피벗(pivot)이라고 불리는 기준 요소 선택 후 피벗보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치시키는 방식
- **최악의 경우**: 피벗이 리스트의 가장 큰 값이나 가장 작은 값으로 선택되는 경우 → 리스트가 한쪽으로 치우쳐 분할 발생하므로 시간 복잡도는 O(n^2)
- **시간 복잡도 분석**: 피벗을 기준으로 리스트를 절반씩 나누어 각 분할 진행 → 리스트가 절반으로 나뉠 때마다 log n번 분할 후 n개의 요소를 비교하므로 평균 시간 복잡도는 O(n log n)

**힙 정렬 (Heap Sort)**

- **시간 복잡도:** O(n log n)
- **설명**: 힙 정렬은 최대 힙 또는 최소 힙을 이용해 데이터를 정렬
- 최악의 경우: 데이터분포 상태나 입력 값 순서 상관없이 동일한 과정으로 힙을 구성하고 정렬 → 최악의 경우에도 성능 저하가 발생 X 시간 복잡도 유지
- **시간 복잡도 분석**: 힙 구성에 O(n)의 시간이 소요 후 힙에서 요소를 제거하는 데 O(log n)의 시간이 필요 → 이를 모든 요소에 대해 반복하므로 전체 시간 복잡도는 O(n log n)

---

## 💡 참고 자료

- https://www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/
- https://blog.chulgil.me/algorithm/