## ğŸ“– í•™ìŠµ ì£¼ì œ

- **ì£¼ì œ**: í•´ì‹œ í…Œì´ë¸”
- **ë‚ ì§œ**: 2024-10-26

---

## ğŸ“Œ í•™ìŠµ ë‚´ìš© ìš”ì•½

### [í•´ì‹œ í…Œì´ë¸”]

**í•´ì‹œ í…Œì´ë¸”**

- `í•´ì‹œ í…Œì´ë¸”(hash table)` : í‚¤(key)ì™€ ê°’(value)ì˜ ëŒ€ì‘ìœ¼ë¡œ ì´ë£¨ì–´ì§„ í…Œì´ë¸”ê³¼ ê°™ì€ í˜•íƒœì˜ ìë£Œêµ¬ì¡°
- `í‚¤(key)` : í•´ì‹œ í…Œì´ë¸”ì— ëŒ€í•œ ì…ë ¥
- `ê°’(value)` : í‚¤ë¥¼ í†µí•´ ì–»ê³ ì í•˜ëŠ” ë°ì´í„°
- `ë²„í‚·(bucket)` : ê°’ì´ ì €ì¥ë˜ì–´ ìˆëŠ” ê³³
    - ì—¬ëŸ¬ ê°œ ì¡´ì¬ â†’ ì—¬ëŸ¬ ë²„í‚·ì´ ë°°ì—´ í˜•ì„±
- `ë¡œë“œ íŒ©í„°(load factor)` : í•´ì‹œ í…Œì´ë¸”ì— ì €ì¥ëœ ë°ì´í„° ìˆ˜ë¥¼ ë²„í‚·ì˜ ìˆ˜ë¡œ ë‚˜ëˆˆ ê°’
    - í…Œì´ë¸”ì´ ì–¼ë§ˆë‚˜ ê°€ë“ ì°¨ ìˆëŠ”ì§€ì— ëŒ€í•œ ì§€í‘œ
    - ë¡œë“œ íŒ©í„°ê°€ í´ìˆ˜ë¡ í•´ì‹œ í…Œì´ë¸” ì„±ëŠ¥ â†“
- **êµ¬ì¡°**

  ![image (15)](https://github.com/user-attachments/assets/60aaa45c-d220-4b6e-965c-b47c108dab9b)

- ê²€ìƒ‰, ì‚½ì…, ì‚­ì œ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ : O(1) â†’ ì…ë ¥ê³¼ ë¬´ê³ ë‚˜í•˜ê²Œ í•­ìƒ ì¼ì •í•œ ì†ë„ ë³´ì¥
- **ë‹¨ì **
    - ì†ë„ â†‘ but, ë©”ëª¨ë¦¬ ê³µê°„ ì†Œëª¨ å¤š
    - ê³µê°„ ë³µì¡ë„ê°€ ì‹œê°„ ë³µì¡ë„ë§Œí¼ ìš°ìˆ˜í•˜ì§€ X
    - ì¶©ëŒ ë¬¸ì œ í•´ê²° í•„ìš”

---

### [í•´ì‹œ í•¨ìˆ˜]

**í•´ì‹œ í•¨ìˆ˜**

- `í•´ì‹œ í•¨ìˆ˜(hash function)` : ì„ì˜ì˜ ê¸¸ì´ë¥¼ ì§€ë‹Œ ë°ì´í„°ë¥¼ ê³ ì •ëœ ê¸¸ì´ì˜ ë°ì´í„°ë¡œ ë³€í™˜í•˜ëŠ” ë‹¨ë°©í–¥ í•¨ìˆ˜
- íŠ¹ì • ì…ë ¥ ë°ì´í„°ë¥¼ ê³ ì •ëœ ê¸¸ì´ì˜ í•´ì‹œ ê°’ìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥
- í•´ì‹œ ê°’ì„ í† ëŒ€ë¡œ ì–´ë–¤ ë°ì´í„°ê°€ ì…ë ¥ ë˜ì—ˆëŠ”ì§€ ë„ì¶œ ì–´ë ¤ì›€
- ë¬´ì‘ìœ„ ê°’ì„ ë§Œë“¤ê±°ë‚˜ ë‹¨ë°©í–¥ ì•”í˜¸ë¥¼ ë§Œë“¤ ë•Œ, ë°ì´í„° ë¬´ê²°ì„±ì„ ê²€ì¦í•˜ê¸° ìœ„í•´ ì‚¬ìš©

  ![image (16)](https://github.com/user-attachments/assets/9544c57d-cf07-4e4f-9924-babbf34b4595)


**í•´ì‹œ ì•Œê³ ë¦¬ì¦˜**

- `í•´ì‹œ ì•Œê³ ë¦¬ì¦˜(hash algorithm)` : í•´ì‹œ í•¨ìˆ˜ì˜ ì—°ì‚° ë°©ë²•
- ê°™ì€ ë°ì´í„°ì—¬ë„ ì ìš©ëœ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¼ ë„ì¶œë˜ëŠ” í•´ì‹œ ê°’ì˜ ê¸¸ì´ë‚˜ ê°’ì´ ë‹¬ë¼ì§
- **ì¢…ë¥˜**
    - MD5
    - SHA-1
    - SHA-256
    - SHA-512
    - SHA3
    - HMAC

---

### [í•´ì‹œ ì¶©ëŒ]

**í•´ì‹œ ì¶©ëŒ**

- `í•´ì‹œ ì¶©ëŒ(hash collision)` : ì„œë¡œ ë‹¤ë¥¸ í‚¤ì— ëŒ€í•´ ê°™ì€ í•´ì‹œ ê°’ì´ ëŒ€ì‘ë˜ëŠ” ìƒí™©

**í•´ê²° ë°©ë²• - ì²´ì´ë‹**

- `ì²´ì´ë‹(chaining)` : ì¶©ëŒì´ ë°œìƒí•œ ë°ì´í„°ë¥¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì¶”ê°€
    - ë‹¨ìˆœ ë…¸ë“œ ì¶”ê°€ì´ê¸° ë•Œë¬¸ì— ì„œë¡œ ë‹¤ë¥¸ í‚¤ê°€ ê°™ì€ ìœ„ì¹˜ë¡œ í•´ì‹œ
    - í•˜ë‚˜ì˜ í…Œì´ë¸” ì¸ë±ìŠ¤ì— ì—¬ëŸ¬ ë°ì´í„°ê°€ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ ì¡´ì¬ ê°€ëŠ¥

  ![image (17)](https://github.com/user-attachments/assets/6cc6155b-06e2-47eb-a8fa-ca449549c180)


**í•´ê²° ë°©ë²• - ê°œë°© ì£¼ì†Œë²•**

- `ê°œë°© ì£¼ì†Œë²•(open addressing)` : ì¶©ëŒì´ ë°œìƒí•œ ë²„í‚·ì˜ ì¸ë±ìŠ¤ê°€ ì•„ë‹Œ ë‹¤ë¥¸ ì¸ë±ìŠ¤ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë°©ë²•
- `ì¡°ì‚¬(probe)` : ì¶©ëŒ ë°œìƒ ì‹œ ë¹„ì–´ ìˆëŠ” ë‹¤ë¥¸ ë²„í‚·ì˜ ì¸ë±ìŠ¤ ì°¾ëŠ” ê³¼ì •
- `ì„ í˜• ì¡°ì‚¬ë²•(linear probing)` : ì¶©ëŒì´ ë°œìƒí•œ ì¸ë±ìŠ¤ì˜ ë‹¤ìŒ ì¸ë±ìŠ¤ë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ ê°€ìš©í•œ ì¸ë±ìŠ¤ ì°¾ëŠ” ë°©ë²•
    - **ë‹¨ì **
        - êµ°ì§‘í™” ë  ìˆ˜ ìˆìŒ
- `êµ°ì§‘í™”(clustering)` : ì¶©ëŒ ì‹œ ë°œìƒí•˜ëŠ” ì¸ë±ìŠ¤ ì¸ê·¼ì— ì¶©ëŒì´ ë°œìƒí•œ ì—¬ëŸ¬ ë°ì´í„°ê°€ ëª°ë ¤ ì €ì¥ë˜ëŠ” ê²ƒ
    - ì˜¤ëœ ìˆœì°¨ íƒìƒ‰ í•„ìš” â†’ ì„±ëŠ¥ ì•…í™” ê°€ëŠ¥ì„± é«˜
- `ì´ì°¨ ì¡°ì‚¬ë²•(quadratic probint)` : ì„ í˜• ì¡°ì‚¬ë²• ì™„í™”, ì´ëŒ ë°œìƒ ì‹œ ì¸ë±ìŠ¤ì—ì„œ ì œê³±ìˆ˜ë§Œí¼ ë–¨ì–´ì§„ ê±°ë¦¬ì— ìœ„ì¹˜í•œ ì¸ë±ìŠ¤ ì°¾ëŠ” ë°©ë²•
    - êµ°ì§‘í™” ë¬¸ì œ ì™„í™” O â†’ ê·¼ë³¸ì ì¸ í•´ê²° ë°©ë²• X

**í•´ê²° ë°©ë²• - ì´ì¤‘ í•´ì‹±**

- `ì´ì¤‘ í•´ì‹±(double hashing)` : 2ê°œì˜ í•´ì‹œ í•¨ìˆ˜ ì‚¬ìš©, ì¶©ëŒ ë°œìƒ ì‹œ ë‹¤ë¥¸ í•´ì‹œ í•¨ìˆ˜(ë³´ì¡° í•´ì‹œ í•¨ìˆ˜)ì— ëŒ€í•œ í•´ì‹œ ê°’ë§Œí¼ ë–¨ì–´ì§„ ê±°ë¦¬ì— ìœ„ì¹˜í•œ ì¸ë±ìŠ¤ ì°¾ëŠ” ë°©ë²•
    - ë¬´ì‘ìœ„ ì¸ë±ìŠ¤ ìƒì„± â†’ ì„ í˜• ì¡°ì‚¬ë²•ì˜ êµ°ì§‘í™” ë¬¸ì œ ëŒ€ë¶€ë¶„ í•´ê²° ê°€ëŠ¥

---

## ğŸ“ˆ ì¶”ê°€ í•™ìŠµ í•„ìš”

- **í•´ì‹œ í…Œì´ë¸”ì˜ í™œìš© ì‚¬ë¡€**
    - ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ì‹±
    - ìºì‹œ êµ¬í˜„
    - ë°ì´í„° ì¤‘ë³µ ì œê±° ë“±
- **ì–¸ì–´ë³„ í•´ì‹œ í…Œì´ë¸” êµ¬í˜„**

[[Java]](https://www.geeksforgeeks.org/hashtable-in-java/)
```java
import java.util.Hashtable;

public class HashtableCreation {
    public static void main(String args[]) {
        
      // Create a Hashtable of String keys and Integer values
        Hashtable<String, Integer> hashtable = new Hashtable<>();

        // Adding elements to the Hashtable
        hashtable.put("One", 1);
        hashtable.put("Two", 2);
        hashtable.put("Three", 3);
        
        // Displaying the Hashtable elements
        System.out.println("Hashtable Elements: " + hashtable);
    }
}
```

[[Python]](https://www.geeksforgeeks.org/implementation-of-hash-table-in-python-using-separate-chaining/)
```python
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
```

[[C]](https://www.geeksforgeeks.org/implementation-of-hash-table-in-c-using-separate-chaining/)
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

    // Linked List node
    struct node {
    
    	// key is string
    	char* key;
    
    	// value is also string
    	char* value;
    	struct node* next;
    };
    
    // like constructor
    void setNode(struct node* node, char* key, char* value)
    {
    	node->key = key;
    	node->value = value;
    	node->next = NULL;
    	return;
    };
    
    struct hashMap {
    
    	// Current number of elements in hashMap
    	// and capacity of hashMap
    	int numOfElements, capacity;
    
    	// hold base address array of linked list
    	struct node** arr;
    };
    
    // like constructor
    void initializeHashMap(struct hashMap* mp)
    {
    
    	// Default capacity in this case
    	mp->capacity = 100;
    	mp->numOfElements = 0;
    
    	// array of size = 1
    	mp->arr = (struct node**)malloc(sizeof(struct node*)
    									* mp->capacity);
    	return;
    }
    
    int hashFunction(struct hashMap* mp, char* key)
    {
    	int bucketIndex;
    	int sum = 0, factor = 31;
    	for (int i = 0; i < strlen(key); i++) {
    
    		// sum = sum + (ascii value of
    		// char * (primeNumber ^ x))...
    		// where x = 1, 2, 3....n
    		sum = ((sum % mp->capacity)
    			+ (((int)key[i]) * factor) % mp->capacity)
    			% mp->capacity;
    
    		// factor = factor * prime
    		// number....(prime
    		// number) ^ x
    		factor = ((factor % __INT16_MAX__)
    				* (31 % __INT16_MAX__))
    				% __INT16_MAX__;
    	}
    
    	bucketIndex = sum;
    	return bucketIndex;
    }
    
    void insert(struct hashMap* mp, char* key, char* value)
    {
    
    	// Getting bucket index for the given
    	// key - value pair
    	int bucketIndex = hashFunction(mp, key);
    	struct node* newNode = (struct node*)malloc(
    
    		// Creating a new node
    		sizeof(struct node));
    
    	// Setting value of node
    	setNode(newNode, key, value);
    
    	// Bucket index is empty....no collision
    	if (mp->arr[bucketIndex] == NULL) {
    		mp->arr[bucketIndex] = newNode;
    	}
    
    	// Collision
    	else {
    
    		// Adding newNode at the head of
    		// linked list which is present
    		// at bucket index....insertion at
    		// head in linked list
    		newNode->next = mp->arr[bucketIndex];
    		mp->arr[bucketIndex] = newNode;
    	}
    	return;
    }
    
    void delete (struct hashMap* mp, char* key)
    {
    
    	// Getting bucket index for the
    	// given key
    	int bucketIndex = hashFunction(mp, key);
    
    	struct node* prevNode = NULL;
    
    	// Points to the head of
    	// linked list present at
    	// bucket index
    	struct node* currNode = mp->arr[bucketIndex];
    
    	while (currNode != NULL) {
    
    		// Key is matched at delete this
    		// node from linked list
    		if (strcmp(key, currNode->key) == 0) {
    
    			// Head node
    			// deletion
    			if (currNode == mp->arr[bucketIndex]) {
    				mp->arr[bucketIndex] = currNode->next;
    			}
    
    			// Last node or middle node
    			else {
    				prevNode->next = currNode->next;
    			}
    			free(currNode);
    			break;
    		}
    		prevNode = currNode;
    		currNode = currNode->next;
    	}
    	return;
    }
    
    char* search(struct hashMap* mp, char* key)
    {
    
    	// Getting the bucket index
    	// for the given key
    	int bucketIndex = hashFunction(mp, key);
    
    	// Head of the linked list
    	// present at bucket index
    	struct node* bucketHead = mp->arr[bucketIndex];
    	while (bucketHead != NULL) {
    
    		// Key is found in the hashMap
    		if (bucketHead->key == key) {
    			return bucketHead->value;
    		}
    		bucketHead = bucketHead->next;
    	}
    
    	// If no key found in the hashMap
    	// equal to the given key
    	char* errorMssg = (char*)malloc(sizeof(char) * 25);
    	errorMssg = "Oops! No data found.\n";
    	return errorMssg;
    }
    
    // Drivers code
    int main()
    {
    
    	// Initialize the value of mp
    	struct hashMap* mp
    		= (struct hashMap*)malloc(sizeof(struct hashMap));
    	initializeHashMap(mp);
    
    	insert(mp, "Yogaholic", "Anjali");
    	insert(mp, "pluto14", "Vartika");
    	insert(mp, "elite_Programmer", "Manish");
    	insert(mp, "GFG", "GeeksforGeeks");
    	insert(mp, "decentBoy", "Mayank");
    
    	printf("%s\n", search(mp, "elite_Programmer"));
    	printf("%s\n", search(mp, "Yogaholic"));
    	printf("%s\n", search(mp, "pluto14"));
    	printf("%s\n", search(mp, "decentBoy"));
    	printf("%s\n", search(mp, "GFG"));
    
    	// Key is not inserted
    	printf("%s\n", search(mp, "randomKey"));
    
    	printf("\nAfter deletion : \n");
    
    	// Deletion of key
    	delete (mp, "decentBoy");
    	printf("%s\n", search(mp, "decentBoy"));
    
    	return 0;
    }
```


---

## ğŸ’¡ ì°¸ê³  ìë£Œ

- [Hash Table](https://www.geeksforgeeks.org/hash-table-data-structure/)
- [Hash Function](https://www.geeksforgeeks.org/hash-functions-and-list-types-of-hash-functions/)
- [Open addressing](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)
