## ğŸ“– í•™ìŠµ ì£¼ì œ

- **ì£¼ì œ**: ê·¸ë˜í”„
- **ë‚ ì§œ**: 2024-10-28

---

## ğŸ“Œ í•™ìŠµ ë‚´ìš© ìš”ì•½

### [ê·¸ë˜í”„ì˜ ì¢…ë¥˜ì™€ êµ¬í˜„]

**ê·¸ë˜í”„**

- `ê·¸ë˜í”„(Graph)` : ì •ì ì´ë¼ ë¶ˆë¦¬ëŠ” ë°ì´í„°ë¥¼ ê°„ì„  í˜¹ì€ ë§í¬ë¡œ ì—°ê²°í•œ í˜•íƒœ
    - ë°ì´í„° ê°„ì˜ ì—°ê²° ê´€ê³„ë¥¼ í‘œí˜„
- `ì—°ê²° ê·¸ë˜í”„(connected graph)` : ì„ì˜ì˜ ë‘ ì •ì  ì‚¬ì´ì˜ ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ” ê·¸ë˜í”„
- `ë¹„ì—°ê²° ê·¸ë˜í”„(disconnected graph)` : ì •ì  ì‚¬ì´ì— ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ ìˆëŠ” ê·¸ë˜í”„
- `ë°©í–¥ ê·¸ë˜í”„(directed graph)` : ê°„ì„ ì— ë°©í–¥ì´ ìˆëŠ” ê·¸ë˜í”„
- `ë¬´ë°©í–¥ ê·¸ë˜í”„(undirected graph)` : ê°„ì„ ì— ë°©í–¥ì´ ì—†ëŠ” ê·¸ë˜í”„
- `ê°€ì¤‘ì¹˜ ê·¸ë˜í”„(weighted graph)` : ê°„ì„ ì— ê°€ì¤‘ì¹˜ê°€ ë¶€ì—¬ëœ ê·¸ë˜í”„
    - ë¹„ìš©(cost) : ê°„ì„ ì— ë¶€ì—¬ëœ ê°’
- `ì„œë¸Œ ê·¸ë˜í”„(subgraph)` : íŠ¹ì • ê·¸ë˜í”„ì˜ ì •ì ê³¼ ê°„ì„ ì˜ ì¼ë¶€ë¶„ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ê·¸ë˜í”„

**ì¸ì ‘ í–‰ë ¬ ê¸°ë°˜ ê·¸ë˜í”„ í‘œí˜„**

- N X N í¬ê¸°ì˜ í–‰ë ¬ë¡œ ê·¸ë˜í”„ í‘œí˜„í•˜ëŠ” ë°©ë²•
    - ë¬´ë°©í–¥ ê·¸ë˜í”„

      ![image (11)](https://github.com/user-attachments/assets/ee80e131-4410-4a3c-b45f-ba96ac09b5e8)

    - ë°©í–¥ ê·¸ë˜í”„

      ![image (10)](https://github.com/user-attachments/assets/f88c9048-5e2e-4c20-bded-b9a638f7c421)


**ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ê·¸ë˜í”„ í‘œí˜„**

- ê·¸ë˜í”„ì˜ íŠ¹ì • ì •ì ê³¼ ì—°ê²°ëœ ì •ì ë“¤ì„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•˜ëŠ” ë°©ë²•

  ![image (9)](https://github.com/user-attachments/assets/a4b5345f-3662-4cfe-bbaa-588081a8a52f)


---

### [ê¹Šì´ ìš°ì„  íƒìƒ‰ê³¼ ë„ˆë¹„ ìš°ì„  íƒìƒ‰]

**ê¹Šì´ ìš°ì„  íƒìƒ‰**

- `DFS(Depth-First Search)` : ê·¸ë˜í”„ì—ì„œ ë” ì´ìƒ ë°©ë¬¸ ê°€ëŠ¥í•œ ì •ì ì´ ì—†ì„ ë•Œê¹Œì§€ ìµœëŒ€í•œ ê¹Šì´ íƒìƒ‰í•˜ê¸°ë¥¼ ë°˜ë³µí•˜ëŠ” íƒìƒ‰ ë°©ë²•

    ```java
    import java.util.*;
    
    public class DFSExample {
        private static void dfs(int node, boolean[] visited, List<List<Integer>> graph) {
            // í˜„ì¬ ë…¸ë“œë¥¼ ë°©ë¬¸ ì²˜ë¦¬
            visited[node] = true;
            System.out.print(node + " ");
            
            // ì¸ì ‘í•œ ë…¸ë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë°©ë¬¸
            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) {
                    dfs(neighbor, visited, graph);
                }
            }
        }
    
        public static void main(String[] args) {
            int n = 5; // ë…¸ë“œ ê°œìˆ˜
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i <= n; i++) {
                graph.add(new ArrayList<>());
            }
    
            // ê·¸ë˜í”„ ì—°ê²° ì •ë³´ ì„¤ì •
            graph.get(1).add(2);
            graph.get(1).add(3);
            graph.get(2).add(4);
            graph.get(3).add(5);
    
            boolean[] visited = new boolean[n + 1];
            System.out.print("DFS: ");
            dfs(1, visited, graph);
        }
    }
    
    ```


**ë„ˆë¹„ ìš°ì„  íƒìƒ‰**

- BFS(Breadth-First Search) : ê·¸ë˜í”„ì—ì„œ ë” ì´ìƒ ë°©ë¬¸ ê°€ëŠ¥í•œ ì •ì ì´ ì—†ì„ ë•Œê¹Œì§€ ìµœëŒ€í•œ ë„“ê²Œ íƒìƒ‰í•˜ê¸°ë¥¼ ë°˜ë³µí•˜ëŠ” íƒìƒ‰ ë°©ë²•

    ```java
    import java.util.*;
    
    public class BFSExample {
        private static void bfs(int start, List<List<Integer>> graph) {
            Queue<Integer> queue = new LinkedList<>();
            boolean[] visited = new boolean[graph.size()];
    
            queue.add(start);
            visited[start] = true;
    
            while (!queue.isEmpty()) {
                int node = queue.poll();
                System.out.print(node + " ");
                
                for (int neighbor : graph.get(node)) {
                    if (!visited[neighbor]) {
                        queue.add(neighbor);
                        visited[neighbor] = true;
                    }
                }
            }
        }
    
        public static void main(String[] args) {
            int n = 5; // ë…¸ë“œ ê°œìˆ˜
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i <= n; i++) {
                graph.add(new ArrayList<>());
            }
    
            // ê·¸ë˜í”„ ì—°ê²° ì •ë³´ ì„¤ì •
            graph.get(1).add(2);
            graph.get(1).add(3);
            graph.get(2).add(4);
            graph.get(3).add(5);
    
            System.out.print("BFS: ");
            bfs(1, graph);
        }
    }
    
    ```


---

### [ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜]

**ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜**

- `ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜` : í•œ ì •ì ì—ì„œ ëª©ì ì§€ ì •ì ê¹Œì§€ ì´ë¥´ëŠ” ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” ê²½ë¡œë¥¼ ê²°ì •í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- **ì‹¤ìƒí™œ ì˜ˆ**
    - ì§€ë„ ì„œë¹„ìŠ¤ (ì›í•˜ëŠ” ëª©ì ì§€ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬)
    - ì»´í“¨í„° ë„¤íŠ¸ì›Œí¬


**ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**

- `Dijkstraâ€™s Algorithm` : ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ìŒì´ ì•„ë‹Œ ìˆ˜ë¼ëŠ” ê°€ì • í•˜ì— ì‚¬ìš© ê°€ëŠ¥í•œ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜
- **ë™ì‘ ë°©ì‹**
    - ì‹œì‘ ì •ì  ì œì™¸í•œ ì •ì  ì´ˆê¸°í™”
    - (ì‹œì‘) ì •ì  ë°©ë¬¸
    - ê²½ë¡œ ìƒ ê°€ì¤‘ì¹˜ í•©ê³¼ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸” ìƒ ê°’ ë¹„êµ
    - ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸” ê°±ì‹  ê°€ëŠ¥í•˜ë©´ ê°±ì‹ 
    - ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì  ì¤‘ ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì‘ì€ ì •ì  ë°©ë¬¸
    - ë” ì´ìƒ ë°©ë¬¸í•  ì •ì ì´ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ

    ```java
    import java.util.*;
    
    public class DijkstraExample {
        static class Node implements Comparable<Node> {
            int vertex;
            int distance;
    
            public Node(int vertex, int distance) {
                this.vertex = vertex;
                this.distance = distance;
            }
    
            // ìš°ì„ ìˆœìœ„ íì—ì„œ ê±°ë¦¬ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê¸° ìœ„í•œ ë¹„êµ í•¨ìˆ˜
            @Override
            public int compareTo(Node other) {
                return Integer.compare(this.distance, other.distance);
            }
        }
    
        public static int[] dijkstra(int start, List<List<Node>> graph, int n) {
            PriorityQueue<Node> pq = new PriorityQueue<>();
            int[] distances = new int[n + 1];
            Arrays.fill(distances, Integer.MAX_VALUE);
            distances[start] = 0;
    
            pq.add(new Node(start, 0));
    
            while (!pq.isEmpty()) {
                Node current = pq.poll();
                int currentVertex = current.vertex;
                int currentDistance = current.distance;
    
                // ì´ë¯¸ ì²˜ë¦¬ëœ ë…¸ë“œì˜ ìµœë‹¨ ê²½ë¡œë³´ë‹¤ í° ê²½ìš° ë¬´ì‹œ
                if (currentDistance > distances[currentVertex]) continue;
    
                // ì¸ì ‘ ë…¸ë“œ í™•ì¸
                for (Node neighbor : graph.get(currentVertex)) {
                    int newDist = distances[currentVertex] + neighbor.distance;
    
                    // ë” ì§§ì€ ê²½ë¡œê°€ ë°œê²¬ë˜ë©´ ê°±ì‹ 
                    if (newDist < distances[neighbor.vertex]) {
                        distances[neighbor.vertex] = newDist;
                        pq.add(new Node(neighbor.vertex, newDist));
                    }
                }
            }
    
            return distances;
        }
    
        public static void main(String[] args) {
            int n = 5; // ë…¸ë“œ ê°œìˆ˜
            List<List<Node>> graph = new ArrayList<>();
            for (int i = 0; i <= n; i++) {
                graph.add(new ArrayList<>());
            }
    
            // ê·¸ë˜í”„ ì—°ê²° ì„¤ì • (ë…¸ë“œ, ê°€ì¤‘ì¹˜)
            graph.get(1).add(new Node(2, 2));
            graph.get(1).add(new Node(3, 5));
            graph.get(2).add(new Node(3, 3));
            graph.get(2).add(new Node(4, 1));
            graph.get(3).add(new Node(4, 2));
            graph.get(4).add(new Node(5, 1));
    
            int start = 1; // ì‹œì‘ ë…¸ë“œ
            int[] distances = dijkstra(start, graph, n);
    
            System.out.println("ë…¸ë“œ " + start + "ì—ì„œ ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬:");
            for (int i = 1; i <= n; i++) {
                System.out.println("ë…¸ë“œ " + i + " : " + distances[i]);
            }
        }
    }
    ```


---

## ğŸ’¡ ì°¸ê³  ìë£Œ

- [adjacency matrix of a graph](https://www.geeksforgeeks.org/adjacency-matrix-meaning-and-definition-in-dsa/)
- [adjacency list of a graph](https://www.geeksforgeeks.org/adjacency-list-meaning-definition-in-dsa/)
- [DFS](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)
- [BFS](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)
- [Dijkstra Algorithm](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)